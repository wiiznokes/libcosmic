searchState.loadedDescShard("zvariant", 0, "zvariant\nThe prefix of ARRAY type signature, as a character. …\nThe prefix of ARRAY type signature, as a string. Provided …\nA helper type to wrap arrays in a <code>Value</code>.\nThe maximum allowed depth for arrays in encoding was …\nUse this to deserialize an Array.\nTrait for basic types.\nThe maximum allowed depth for containers in encoding was …\nD-Bus format.\nThe closing character of DICT_ENTRY type signature. …\nThe closing character of DICT_ENTRY type signature, as a …\nThe opening character of DICT_ENTRY type signature. …\nThe opening character of DICT_ENTRY type signature, as a …\nAdds <code>Deserialize</code> implementation to structs to be …\nA wrapper to deserialize a value to <code>T: Type + Deserialize</code>.\nOur deserialization implementation.\nA DeserializeSeed implementation for this type.\nA helper type to wrap dictionaries in a <code>Value</code>.\nTypes that deserialize based on dynamic signatures.\nTypes with dynamic signatures.\nThe encoding context to use with the serialization and …\nThe encoding format.\nContains the error value\nError type used by zvariant API.\nA <code>RawFd</code> wrapper.\nThe type (signature as first argument) being …\nType conversions errors.\nWrapper for <code>std::io::Error</code>\nWrapper for <code>std::io::Error</code>\nEnum representing the max depth exceeded error.\nThe maximum allowed depth for containers in encoding was …\nGeneric error. All serde errors gets transformed into this …\nMissing framing offset at the end of a GVariant-encoded …\nType that uses a special value to be used as none.\nString that identifies objects at a given destination on …\nContains the success value\nAn optional value.\nOut of bounds range specified.\nAn owned <code>RawFd</code> wrapper.\nOwned <code>ObjectPath</code>\nOwned <code>Signature</code>\nOwned <code>Value</code>\nImplements conversions for your type to/from <code>OwnedValue</code>.\nNon-0 padding byte(s) encountered.\nAlias for a <code>Result</code> with the error type <code>zvariant::Error</code>.\nThe type signature, as a character.\nThe type signature, as a string.\nThe closing character of STRUCT type signature. Provided …\nThe closing character of STRUCT type signature, as a …\nThe opening character of STRUCT type signature. Provided …\nThe opening character of STRUCT type signature, as a …\nAdds <code>Serialize</code> implementation to structs to be serialized …\nA wrapper to serialize <code>T: Type + Serialize</code> as a value.\nOur serialization implementation.\nString that identifies the type of an encoded value.\nThe provided signature (first argument) was not valid for …\nA string wrapper.\nA helper type to wrap structs in <code>Value</code>.\nThe maximum allowed depth for structures in encoding was …\nUse this to efficiently build a <code>Structure</code>.\nUse this to deserialize a <code>Structure</code>.\nTrait implemented by all serializable types.\nDerive macro to add <code>Type</code> implementation to structs and …\nDerive macro to add <code>Type</code> implementation to structs …\nThe deserialized file descriptor is not in the given FD …\nWrapper for <code>std::str::Utf8Error</code>\nThe VARIANT type signature. Provided for manual signature …\nThe VARIANT type signature, as a string. Provided for …\nA generic container, in the form of an enum that holds …\nImplements conversions for your type to/from <code>Value</code>.\nAdd a new entry.\nAppend <code>field</code> to <code>self</code>.\nThe required padding alignment for the given format.\nAppend <code>element</code>.\nAppend <code>key</code> and <code>value</code> as a new entry.\nAppend <code>field</code> to <code>self</code>.\nThe object path as bytes.\nThe signature bytes.\nA borrowed clone (this never allocates, unlike clone).\nA borrowed clone (this never allocates, unlike clone).\nThe object path as a string.\nThe signature as a string.\nThe underlying string.\nBuild the <code>Structure</code>.\nGet a deserializer compatible with this signature.\nTry to get the underlying type <code>T</code>.\nTry to get a reference to the underlying type <code>T</code>.\nGet the signature for the implementing type.\nGet the signature of the elements in the <code>Array</code>.\nGet a reference to all the fields of <code>self</code>.\nThe <code>EncodingFormat</code> of this context.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCreate a new <code>ObjectPath</code> from given bytes.\nCreate a new Signature from given bytes.\nDeserialize <code>T</code> from a given slice of bytes.\nDeserialize <code>T</code> from a given slice of bytes, containing file …\nDeserialize <code>T</code> from a given slice of bytes containing file …\nDeserialize <code>T</code> from a given slice of bytes containing file …\nDeserialize <code>T</code> from a given slice of bytes containing file …\nDeserialize <code>T</code> from a given slice of bytes containing file …\nDeserialize <code>T</code> from a given slice of bytes with the given …\nDeserialize <code>T</code> from a given slice of bytes containing file …\nAn owned string without allocations\nSame as <code>from_static_bytes_unchecked</code>, except it checks …\nSame as <code>from_bytes_unchecked</code>, except it takes a static …\nSame as <code>try_from</code>, except it takes a <code>&amp;&#39;static str</code>.\nSame as <code>from_static_str_unchecked</code>, except it checks …\nSame as <code>from_str_unchecked</code>, except it takes a <code>&amp;&#39;static str</code>.\nSame as <code>from_str_unchecked</code>, except it takes a static …\nCreate a new <code>ObjectPath</code> from the given string.\nSame as <code>from_bytes_unchecked</code>, except it takes a string …\nSame as <code>from_str_unchecked</code>, except it takes an owned <code>String</code>…\nSame as <code>from_str_unchecked</code>, except it takes an owned <code>String</code>…\nGet the signature of this <code>Array</code>.\nGet the signature of this <code>Dict</code>.\nGet the signature of this <code>Structure</code>.\nGet all the elements.\nGet the value for the given key.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nConverts <code>self</code> to a <code>Vec</code> containing all its fields.\nUnwrap the <code>Writer</code> reference from the <code>Serializer</code>.\nCreates an owned clone of <code>self</code>.\nCreates an owned clone of <code>self</code>.\nCreates an owned clone of <code>self</code>.\nif the object path is empty.\nif the signature is empty.\nGet the number of elements.\nthe object path’s length.\nthe signature’s length.\nCreate a new empty <code>Array</code>, given the signature of the …\nCreate a Serializer struct instance.\nCreate a Deserializer struct instance.\nCreate a new empty <code>Array</code>, given the signature of the …\nCreate a new empty <code>Dict</code>, given the signature of the keys …\nCreate a new encoding context.\nCreate a new <code>StructureBuilder</code>.\nMake a <code>Value</code> for a given value.\nConvenient wrapper for <code>new</code> to create a context for D-Bus …\nCreate a new <code>StructureSeed</code>\nThe none-equivalent value.\nThe byte position of the value to be encoded or decoded, …\nAppend <code>field</code> to <code>self</code>.\nAppend <code>field</code> to <code>self</code>.\nCalculate the serialized size of <code>T</code>.\nCalculate the serialized size of <code>T</code> that (potentially) …\nGet the signature for the implementing type.\nGet the signature of this <code>Array</code>.\nGet the signature of this <code>Dict</code>.\nGet the signature of this <code>Structure</code>.\nReturns a slice of <code>self</code> for the provided range.\nSerialize <code>T</code> as a byte vector.\nSerialize <code>T</code> that (potentially) contains FDs, as a byte …\nSerialize <code>T</code> that (potentially) contains FDs and has the …\nSerialize <code>T</code> that has the given signature, to a new byte …\nCreates an owned clone of <code>self</code>.\nCreates an owned clone of <code>self</code>.\nCreates an owned clone of <code>self</code>.\nCreate an owned version of <code>self</code>.\nSerialize <code>T</code> to the given <code>writer</code>.\nSerialize <code>T</code> that (potentially) contains FDs, to the given …\nSerialize <code>T</code> that (potentially) contains FDs and has the …\nSerialize <code>T</code> that has the given signature, to the given …\nGet the signature of the enclosed value.\nOur D-Bus deserialization implementation.\nOur D-Bus serialization implementation.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCreate a D-Bus Serializer struct instance.\nCreate a Deserializer struct instance.")